%YAML 1.2
---
# Based on https://tools.ietf.org/html/rfc6020
name: Yang
file_extensions:
  - yang
scope: source.yang
variables:
  ident: '[a-zA-Z_][a-zA-Z0-9_\.\-]*'
  b_l: '(?<![-\w])'
  b_r: '(?![-\w])'
  int_types: '(int8|int16|int32|int64|uint8|uint16|uint32|uint64)'
  yang_types: '({{int_types}}|decimal64|string|boolean|enumeration|bits|binary|leafref|identityref|empty|union|instance-identifier)'

  yang_lang_const: '(true|false|current|deprecated|obsolete|not-supported|add|replace|delete|unbounded|system|user|min|max)'
  #custom_keyword: '({{ident}}:{{ident}})'
  unq_string: '[^\s;{}(\/\/)(\/\*)(\*\/)]+'
contexts:
  main:
    - include: comments
    - include: statements

  comments:
    # Line comments begin with a '//' and finish at the end of the line
    - match: '//'
      scope: punctuation.definition.comment.yang
      push: line_comment

    # Block comments begin with a '/*' and finish with a '*/'
    - match: '/\*'
      scope: punctuation.definition.comment.yang
      push: block_comment

  statements:
    - match: '{{b_l}}(module){{b_r}}'
      scope: keyword.other.yang
      set: stmt_module
    - match: '{{b_l}}(submodule){{b_r}}'
      scope: keyword.other.yang
      set: stmt_submodule
    - match: '{{b_l}}(typedef){{b_r}}'
      scope: keyword.other.yang
      set: stmt_typedef
    - match: '{{b_l}}(container){{b_r}}'
      scope: keyword.other.yang
      set: stmt_container
    - match: '{{b_l}}(leaf){{b_r}}'
      scope: keyword.other.yang
      set: stmt_leaf
    - match: '{{b_l}}(leaf-list){{b_r}}'
      scope: keyword.other.yang
      set: stmt_leaf-list
    - match: '{{b_l}}(list){{b_r}}'
      scope: keyword.other.yang
      set: stmt_list
    - match: '{{b_l}}(grouping){{b_r}}'
      scope: keyword.other.yang
      set: stmt_grouping
    - match: '{{b_l}}(choice){{b_r}}'
      scope: keyword.other.yang
      set: stmt_choice
    - match: '{{b_l}}(anyxml){{b_r}}'
      scope: keyword.other.yang
      set: stmt_anyxml
    - match: '{{b_l}}(uses){{b_r}}'
      scope: keyword.other.yang
      set: stmt_uses
    - match: '{{b_l}}(rpc){{b_r}}'
      scope: keyword.other.yang
      set: stmt_rpc
    - match: '{{b_l}}(notification){{b_r}}'
      scope: keyword.other.yang
      set: stmt_notification
    - match: '{{b_l}}(augment){{b_r}}'
      scope: keyword.other.yang
      set: stmt_augment
    - match: '{{b_l}}(identity){{b_r}}'
      scope: keyword.other.yang
      set: stmt_identity
    - match: '{{b_l}}(extension){{b_r}}'
      scope: keyword.other.yang
      set: stmt_extension

  stmt_module:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.module.yang
      set: stmt_end

  stmt_submodule:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.submodule.yang
      set: stmt_end

  stmt_typedef:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.type.yang
      set: stmt_end

  stmt_container:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.container.yang
      set: stmt_end

  stmt_leaf:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.leaf.yang
      set: stmt_end

  stmt_leaf-list:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.leaf-list.yang
      set: stmt_end

  stmt_list:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.list.yang
      set: stmt_end

  stmt_grouping:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: entity.name.grouping.yang
      set: stmt_end

  stmt_choice:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_anyxml:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_uses:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_rpc:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_notification:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_augment:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_identity:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_extension:
    - match: '{{b_l}}({{ident}}){{b_r}}'
      captures:
        1: variable.parameter.yang
      set: stmt_end

  stmt_end:
    - match: ';'
      scope: punctuation.terminator.yang
      pop: true
    - match: '{'
      scope: punctuation.terminator.yang
      pop: true




  storage:
    # Type statement
    - match: '{{b_l}}(type)\s+({{yang_types}})\s*[{|;]'
      scope: meta.statement.type.yang
      captures:
        1: keyword.operator.type.yang
        2: storage.type.yang

  other:
    # Yang-version statement
    - match: '{{b_l}}(yang-version)\s+(\".*\")\s*;'
      scope: meta.statement.yang-version.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Namespace statement
    - match: '{{b_l}}(namespace)\s+(\".*\")\s*;'
      scope: meta.statement.namespace.yang
      captures:
        1: keyword.other.yang
        2: entity.name.namespace

    # Prefix statement
    - match: '{{b_l}}(prefix)\s+(\"{{ident}}\")\s*;'
      scope: meta.statement.prefix.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Import statement
    - match: '{{b_l}}(import)\s+({{ident}})\s+{'
      scope: meta.statement.import.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Revision-date statement
    - match: '{{b_l}}(revision-date)\s+(\".*\")\s*;'
      scope: meta.statement.revision-date.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Include statement
    - match: '{{b_l}}(include)\s+({{ident}})\s*;'
      scope: meta.statement.include.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Organization statement
    - match: '{{b_l}}(organization)\s+(\".*\")\s*;'
      scope: meta.statement.organization.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Contact statement
    - match: '{{b_l}}(contact)\s+(\".*\")\s*;'
      scope: meta.statement.contact.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Revision statement
    - match: '{{b_l}}(revision)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.revision.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Description statement
    - match: '{{b_l}}(description)\s+(\"[.\n]*\")\s*;'
      scope: meta.statement.description.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Belongs-to statement
    - match: '{{b_l}}(belongs-to)\s+({{ident}})\s+{'
      scope: meta.statement.belongs-to.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Units statement
    - match: '{{b_l}}(units)\s+(\".*\")\s*;'
      scope: meta.statement.units.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Default statment
    - match: '{{b_l}}(default)\s+(\".*\")\s*;'
      scope: meta.statement.default.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Must statement
    - match: '{{b_l}}(must)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.must.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Error-message statement
    - match: '{{b_l}}(error-message)\s+(\".*\")\s*;'
      scope: meta.statement.error-message.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Error-app-tag statement
    - match: '{{b_l}}(error-app-tag)\s+(\".*\")\s*;'
      scope: meta.statement.error-app-tag.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Presence statement
    - match: '{{b_l}}(presence)\s+(\".*\")\s*;'
      scope: meta.statement.presence.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Mandatory statement
    - match: '{{b_l}}(mandatory)\s+(true|false)\s*;'
      scope: meta.statement.mandatory.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    # Min-elements statement
    - match: '{{b_l}}(min-elements)\s+(\d+)\s*;'
      scope: meta.statement.min-elements.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Max-elements statement
    - match: '{{b_l}}(max-elements)\s+(\d+|\"unbounded\")\s*;'
      scope: meta.statement.max-elements.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Ordered-by statement
    - match: '{{b_l}}(ordered-by)\s+(system|user)\s*;'
      scope: meta.statement.ordered-by.yang
      captures:
        1: keyword.other.yang
        2: constant.language.yang

    # Key statement
    - match: '{{b_l}}(key)\s+(\".*\")\s*;'
      scope: meta.statement.key.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Unique statement
    - match: '{{b_l}}(unique)\s+(\".*\")\s*;'
      scope: meta.statement.unique.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Case statement
    - match: '{{b_l}}(case)\s+({{ident}})\s+{'
      scope: meta.statement.case.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Any-xml statement
    - match: '{{b_l}}(any-xml)\s+({{ident}})\s+{'
      scope: meta.statement.any-xml.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Refine statement
    - match: '{{b_l}}(refine)\s+(\".*\")\s+{'
      scope: meta.statement.refine.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Input statement
    - match: '{{b_l}}(input)\s+{'
      scope: meta.statement.input.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Output statement
    - match: '{{b_l}}(output)\s+{'
      scope: meta.statement.output.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Base statement
    - match: '{{b_l}}(base)\s+(\".*\")\s*;'
      scope: meta.statement.base.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Argument statement
    - match: '{{b_l}}(argument)\s+(\".*\")\s+{'
      scope: meta.statement.argument.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Yin-element statement
    - match: '{{b_l}}(yin-element)\s+(true|false)\s*;'
      scope: meta.statement.yin-element.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    # Feature statement
    - match: '{{b_l}}(feature)\s+({{ident}})\s+{'
      scope: meta.statement.feature.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # If-feature statement
    - match: '{{b_l}}(if-feature)\s+({{ident}})\s*;'
      scope: meta.statement.if-feature.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Deviation statement
    - match: '{{b_l}}(deviation)\s+(\".*\")\s+{'
      scope: meta.statement.deviation.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Deviate statement
    - match: '{{b_l}}(deviate)\s+(not-supported|add|replace|delete)\s*;'
      scope: meta.statement.deviate.yang
      captures:
        1: keyword.other.yang
        2: constant.language.yang

    # Config statement
    - match: '{{b_l}}(config)\s+(true|false)\s*;'
      scope: meta.statement.config.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    # Status statement
    - match: '{{b_l}}(status)\s+(current|deprecated|obsolete)\s*;'
      scope: meta.statement.status.yang
      captures:
        1: keyword.other.yang
        2: constant.language.yang

    # Reference statement
    - match: '{{b_l}}(reference)\s+(\".*\")\s*;'
      scope: meta.statement.reference.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # When statement
    - match: '{{b_l}}(when)\s+(\".*\")\s*;'
      scope: meta.statement.when.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Range statement
    - match: '{{b_l}}(range)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.range.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Fraction-digits statement
    - match: '{{b_l}}(fraction-digits)\s+(\d+)'
      scope: meta.statement.fraction-digits.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Length statement
    - match: '{{b_l}}(length)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.length.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Pattern statement
    - match: '{{b_l}}(pattern)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.pattern.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Enum statement
    - match: '{{b_l}}(enum)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.enum.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Value statement
    - match: '{{b_l}}(value)\s+(\d+)\s*[;|{]'
      scope: meta.statement.value.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Bit statement
    - match: '{{b_l}}(bit)\s+({{ident}})\s*[;|{]'
      scope: meta.statement.bit.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Position statement
    - match: '{{b_l}}(position)\s+(\d+)\s*;'
      scope: meta.statement.position.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Path statement
    - match: '{{b_l}}(path)\s+(\".*\")\s*;'
      scope: meta.statement.path.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Require-instance statement
    - match: '{{b_l}}(require-instance)\s+(true|false)\s*;'
      scope: meta.statement.require-instance.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

  constants:
    # Integer constants
    - match: '(?<![\w\-\+])([\+\-])?0x\d+\b'
      scope: constant.numeric.integer.hexadecimal.yang
    - match: '(?<![\w\-\+])([\+\-])?0\d+\b'
      scope: constant.numeric.integer.octal.yang
    - match: '(?<![\w\-\+])([\+\-])?\d+\b'
      scope: constant.numeric.integer.decimal.yang
      # We put the decimal last in order to support a single '0'

    # Decimal64 constant
    - match: '(?<![\w\-\+])([\+\-])?\d+\.\d+\b'
      scope: constant.numeric.real.decimal64.yang

    # Double quoted strings begin with '"' and finish with '"'.
    - match: '"'
      scope: punctuation.definition.string.begin.yang
      push: double_quoted_string

    # Single quoted strings begin with ' and finish with '.
    - match: "'"
      scope: punctuation.definition.string.begin.yang
      push: single_quoted_string

    # Boolean constant
    - match: '{{b_l}}(true|false){{b_r}}'
      scope: constant.language.boolean.yang

    # Language constants
    - match: '{{b_l}}{{yang_lang_const}}{{b_r}}'
      scope: constant.language.yang

    # Unquoted strings have not bounding characters, but spaces, tabs, semicolon,
    # curly braces or comment sequences are not allowed. As this matches pretty
    # much anything, this should probably always be the last rule.
    # - match: 'unq_string'
    #   scope: string.unquoted.yang

  line_comment:
    - meta_scope: comment.line.yang
    - match: $
      pop: true

  block_comment:
    - meta_scope: comment.block.yang
    - match: '\*/'
      scope: punctuation.definition.comment.yang
      pop: true

  double_quoted_string:
    - meta_scope: string.quoted.double.yang
    # Special characters can be introduced using '\'
    - match: '\\[n|t|"|\\]'
      scope: constant.character.escape.yang
    - match: '"'
      scope: punctuation.definition.string.end.yang
      pop: true

  single_quoted_string:
    - meta_scope: string.quoted.single.yang
    # No special characters are allowed
    - match: "'"
      scope: punctuation.definition.string.end.yang
      pop: true
