%YAML 1.2
---
# Based on https://tools.ietf.org/html/rfc6020
name: Yang
file_extensions:
  - yang
scope: source.yang
variables:
  ident: '[a-zA-Z_][a-zA-Z0-9_\.\-]*'
  b_l: '(?<![-\w])'
  b_r: '(?![-\w])'
  int_types: '(int8|int16|int32|int64|uint8|uint16|uint32|uint64)'
  yang_types: '({{int_types}}|decimal64|string|boolean|enumeration|bits|binary|leafref|identityref|empty|union|instance-identifier)'

  yang_lang_const: '(true|false|current|deprecated|obsolete|not-supported|add|replace|delete|unbounded|system|user|min|max)'
  #custom_keyword: '({{ident}}:{{ident}})'
  unq_string: '[^\s;{}(\/\/)(\/\*)(\*\/)]+'
contexts:
  main:
    #
    # Comments
    #

    # Line comments begin with a '//' and finish at the end of the line
    - match: '//'
      scope: punctuation.definition.comment.yang
      push: line_comment

    # Block comments begin with a '/*' and finish with a '*/'
    - match: '/\*'
      scope: punctuation.definition.comment.yang
      push: block_comment

    #
    # Entities
    #

    # Module statement
    - match: '{{b_l}}(module)\s+({{ident}})\s*{'
      scope: meta.statement.module.yang
      captures:
        1: keyword.other.module.yang
        2: entity.name.module.yang

    # Subodule statement
    - match: '{{b_l}}(submodule)\s+({{ident}})\s*{'
      scope: meta.statement.submodule.yang
      captures:
        1: keyword.other.submodule.yang
        2: entity.name.submodule.yang

    # Typedef statement
    - match: '{{b_l}}(typedef)\s+({{ident}})\s*{'
      scope: meta.statement.typedef.yang
      captures:
        1: keyword.other.typedef.yang
        2: entity.name.type.yang

    # Container statement
    - match: '{{b_l}}(container)\s+({{ident}})\s*{'
      scope: meta.statement.container.yang
      captures:
        1: keyword.other.container.yang
        2: entity.name.container.yang

    # Leaf statement
    - match: '{{b_l}}(leaf)\s+({{ident}})\s*{'
      scope: meta.statement.leaf.yang
      captures:
        1: keyword.other.leaf.yang
        2: entity.name.leaf.yang

    # Leaf-list statement
    - match: '{{b_l}}(leaf-list)\s+({{ident}})\s*{'
      scope: meta.statement.leaf-list.yang
      captures:
        1: keyword.other.leaf-list.yang
        2: entity.name.leaf-list.yang

    # List statement
    - match: '{{b_l}}(list)\s+({{ident}})\s*{'
      scope: meta.statement.list.yang
      captures:
        1: keyword.other.list.yang
        2: entity.name.list.yang

    # Grouping statement
    - match: '{{b_l}}(grouping)\s+({{ident}})\s*{'
      scope: meta.statement.grouping.yang
      captures:
        1: keyword.other.grouping.yang
        2: entity.name.grouping.yang

    #
    # Variables
    #

    # Choice statement
    - match: '{{b_l}}(choice)\s+({{ident}})\s*{'
      scope: meta.statement.choice.yang
      captures:
        1: keyword.other.choice.yang
        2: variable.parameter.yang

    # Anyxml statement
    - match: '{{b_l}}(anyxml)\s+({{ident}})\s*{'
      scope: meta.statement.anyxml.yang
      captures:
        1: keyword.other.anyxml.yang
        2: variable.parameter.yang

    # Uses statement
    - match: '{{b_l}}(uses)\s+({{ident}})\s*[{|;]'
      scope: meta.statement.uses.yang
      captures:
        1: keyword.other.uses.yang
        2: variable.parameter.yang

    # Rpc statement
    - match: '{{b_l}}(rpc)\s+({{ident}})\s*[{|;]'
      scope: meta.statement.rpc.yang
      captures:
        1: keyword.other.rpc.yang
        2: variable.parameter.yang

    # Notification statement
    - match: '{{b_l}}(notification)\s+({{ident}})\s*[{|;]'
      scope: meta.statement.notification.yang
      captures:
        1: keyword.other.notification.yang
        2: variable.parameter.yang

    # Augment statement
    - match: '{{b_l}}(augment)\s+({{ident}})\s*[{|;]'
      scope: meta.statement.augment.yang
      captures:
        1: keyword.other.augment.yang
        2: variable.parameter.yang

    # Identity statement
    - match: '{{b_l}}(identity)\s+({{ident}})\s*[{|;]'
      scope: meta.statement.identity.yang
      captures:
        1: keyword.other.identity.yang
        2: variable.parameter.yang

    # Extension statement
    - match: '{{b_l}}(extension)\s+({{ident}})\s*[{|;]'
      scope: meta.statement.extension.yang
      captures:
        1: keyword.other.extension.yang
        2: variable.parameter.yang

    #
    # Storage
    #

    # Type statement
    - match: '{{b_l}}(type)\s+({{yang_types}})\s*[{|;]'
      scope: meta.statement.type.yang
      captures:
        1: keyword.operator.type.yang
        2: storage.type.yang

    #
    # other
    #

    # Yang-version statement
    - match: '{{b_l}}(yang-version)\s+(\".*\")\s*;'
      scope: meta.statement.yang-version.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Namespace statement
    - match: '{{b_l}}(namespace)\s+(\".*\")\s*;'
      scope: meta.statement.namespace.yang
      captures:
        1: keyword.other.yang
        2: entity.name.namespace

    # Prefix statement
    - match: '{{b_l}}(prefix)\s+(\"{{ident}}\")\s*;'
      scope: meta.statement.prefix.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Import statement
    - match: '{{b_l}}(import)\s+({{ident}})\s+{'
      scope: meta.statement.import.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Revision-date statement
    - match: '{{b_l}}(import)\s+(\".*\")\s*;'
      scope: meta.statement.revision-date.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Include statement
    - match: '{{b_l}}(include)\s+({{ident}})\s*;'
      scope: meta.statement.include.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Organization statement
    - match: '{{b_l}}(organization)\s+(\".*\")\s*;'
      scope: meta.statement.organization.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Contact statement
    - match: '{{b_l}}(contact)\s+(\".*\")\s*;'
      scope: meta.statement.contact.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Revision statement
    - match: '{{b_l}}(revision)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.revision.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Description statement
    - match: '{{b_l}}(description)\s+(\".*\")\s*;'
      scope: meta.statement.description.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Belongs-to statement
    - match: '{{b_l}}(belongs-to)\s+({{ident}})\s+{'
      scope: meta.statement.belongs-to.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Units statement
    - match: '{{b_l}}(units)\s+(\".*\")\s*;'
      scope: meta.statement.units.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Default statment
    - match: '{{b_l}}(default)\s+(\".*\")\s*;'
      scope: meta.statement.default.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Must statement
    - match: '{{b_l}}(must)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.must.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Error-message statement
    - match: '{{b_l}}(error-message)\s+(\".*\")\s*;'
      scope: meta.statement.error-message.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Error-app-tag statement
    - match: '{{b_l}}(error-app-tag)\s+(\".*\")\s*;'
      scope: meta.statement.error-app-tag.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Presence statement
    - match: '{{b_l}}(presence)\s+(\".*\")\s*;'
      scope: meta.statement.presence.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Mandatory statement
    - match: '{{b_l}}(mandatory)\s+(true|false)\s*;'
      scope: meta.statement.mandatory.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    # Min-elements statement
    - match: '{{b_l}}(min-elements)\s+(\d)\s*;'
      scope: meta.statement.min-elements.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Max-elements statement
    - match: '{{b_l}}(max-elements)\s+(\d|\"unbounded\")\s*;'
      scope: meta.statement.max-elements.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Ordered-by statement
    - match: '{{b_l}}(ordered-by)\s+(system|user)\s*;'
      scope: meta.statement.ordered-by.yang
      captures:
        1: keyword.other.yang
        2: constant.language.yang

    # Key statement
    - match: '{{b_l}}(key)\s+(\".*\")\s*;'
      scope: meta.statement.key.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Unique statement
    - match: '{{b_l}}(unique)\s+(\".*\")\s*;'
      scope: meta.statement.unique.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Case statement
    - match: '{{b_l}}(case)\s+({{ident}})\s+{'
      scope: meta.statement.case.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Any-xml statement
    - match: '{{b_l}}(any-xml)\s+({{ident}})\s+{'
      scope: meta.statement.any-xml.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Refine statement
    - match: '{{b_l}}(refine)\s+(\".*\")\s+{'
      scope: meta.statement.refine.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Input statement
    - match: '{{b_l}}(input)\s+{'
      scope: meta.statement.input.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Output statement
    - match: '{{b_l}}(output)\s+{'
      scope: meta.statement.output.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Base statement
    - match: '{{b_l}}(base)\s+(\".*\")\s*;'
      scope: meta.statement.base.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Argument statement
    - match: '{{b_l}}(argument)\s+(\".*\")\s+{'
      scope: meta.statement.argument.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Yin-element statement
    - match: '{{b_l}}(yin-element)\s+(true|false)\s*;'
      scope: meta.statement.yin-element.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    # Feature statement
    - match: '{{b_l}}(feature)\s+({{ident}})\s+{'
      scope: meta.statement.feature.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # If-feature statement
    - match: '{{b_l}}(if-feature)\s+({{ident}})\s*;'
      scope: meta.statement.if-feature.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Deviation statement
    - match: '{{b_l}}(deviation)\s+(\".*\")\s+{'
      scope: meta.statement.deviation.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Deviate statement
    - match: '{{b_l}}(deviate)\s+(not-supported|add|replace|delete)\s*;'
      scope: meta.statement.deviate.yang
      captures:
        1: keyword.other.yang
        2: constant.language.yang

    # Config statement
    - match: '{{b_l}}(config)\s+(true|false)\s*;'
      scope: meta.statement.config.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    # Status statement
    - match: '{{b_l}}(status)\s+(current|deprecated|obsolete)\s*;'
      scope: meta.statement.status.yang
      captures:
        1: keyword.other.yang
        2: constant.language.yang

    # Reference statement
    - match: '{{b_l}}(reference)\s+(\".*\")\s*;'
      scope: meta.statement.reference.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # When statement
    - match: '{{b_l}}(when)\s+(\".*\")\s*;'
      scope: meta.statement.when.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Range statement
    - match: '{{b_l}}(range)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.range.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Fraction-digits statement
    - match: '{{b_l}}(fraction-digits)\s+(\d)'
      scope: meta.statement.fraction-digits.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Length statement
    - match: '{{b_l}}(length)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.length.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Pattern statement
    - match: '{{b_l}}(pattern)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.pattern.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Enum statement
    - match: '{{b_l}}(enum)\s+(\".*\")\s*[;|{]'
      scope: meta.statement.enum.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Value statement
    - match: '{{b_l}}(value)\s+(\d)\s*[;|{]'
      scope: meta.statement.value.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Bit statement
    - match: '{{b_l}}(bit)\s+({{ident}})\s*[;|{]'
      scope: meta.statement.bit.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Position statement
    - match: '{{b_l}}(position)\s+(\d)\s*;'
      scope: meta.statement.position.yang
      captures:
        1: keyword.other.yang
        2: constant.numeric.integer.yang

    # Path statement
    - match: '{{b_l}}(path)\s+(\".*\")\s*;'
      scope: meta.statement.path.yang
      captures:
        1: keyword.other.yang
        2: string.yang

    # Require-instance statement
    - match: '{{b_l}}(require-instance)\s+(true|false)\s*;'
      scope: meta.statement.require-instance.yang
      captures:
        1: keyword.other.yang
        2: constant.language.boolean.yang

    #
    # Constants
    #

    # Integer constants
    - match: '(?<![\w\-\+])([\+\-])?0x\d+\b'
      scope: constant.numeric.integer.hexadecimal.yang
    - match: '(?<![\w\-\+])([\+\-])?0\d+\b'
      scope: constant.numeric.integer.octal.yang
    - match: '(?<![\w\-\+])([\+\-])?\d+\b'
      scope: constant.numeric.integer.decimal.yang
      # We put the decimal last in order to support a single '0'

    # Decimal64 constant
    - match: '(?<![\w\-\+])([\+\-])?\d+\.\d+\b'
      scope: constant.numeric.real.decimal64.yang

    # Double quoted strings begin with '"' and finish with '"'.
    - match: '"'
      scope: punctuation.definition.string.begin.yang
      push: double_quoted_string

    # Single quoted strings begin with ' and finish with '.
    - match: "'"
      scope: punctuation.definition.string.begin.yang
      push: single_quoted_string

    # Boolean constant
    - match: '{{b_l}}(true|false){{b_r}}'
      scope: constant.language.boolean.yang

    # Language constants
    - match: '{{b_l}}{{yang_lang_const}}{{b_r}}'
      scope: constant.language.yang

    # Unquoted strings have not bounding characters, but spaces, tabs, semicolon,
    # curly braces or comment sequences are not allowed. As this matches pretty
    # much anything, this should probably always be the last rule.
    # - match: 'unq_string'
    #   scope: string.unquoted.yang

  line_comment:
    - meta_scope: comment.line.yang
    - match: $
      pop: true

  block_comment:
    - meta_scope: comment.block.yang
    - match: '\*/'
      scope: punctuation.definition.comment.yang
      pop: true

  double_quoted_string:
    - meta_scope: string.quoted.double.yang
    # Special characters can be introduced using '\'
    - match: '\\[n|t|"|\\]'
      scope: constant.character.escape.yang
    - match: '"'
      scope: punctuation.definition.string.end.yang
      pop: true

  single_quoted_string:
    - meta_scope: string.quoted.single.yang
    # No special characters are allowed
    - match: "'"
      scope: punctuation.definition.string.end.yang
      pop: true
